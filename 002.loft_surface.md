# 🪡 Loft NURBS Surface from Multiple Curves (OpenNURBS)

여러 **단면 곡선(ON_Curve)** 을 샘플링해 **단순 로프트 NURBS 표면**을 만드는 예제입니다.  
`u`/`v` 방향을 바꿔 쓸 수 있고, `u` 방향 차수도 지정할 수 있어요.

> 엔진: **OpenNURBS**  
> 입력: 단면 곡선들(동일 도메인)  
> 출력: `ON_NurbsSurface`

---



## ✅ 핵심 아이디어

- 모든 단면 곡선의 **공통 파라미터 도메인** `[u0, u1]`을 사용해 `samples_u` 개의 `t`를 균일 샘플링 합니다.
- 각 `t`에서 **모든 곡선의 3D 점**을 계산하여 `W × H` 격자(grid)를 구성합니다.  
  (`W`=곡선 개수, `H`=샘플 수)
- `sweep_u=true` 이면 `u` 방향을 **곡선 인덱스**, `v` 방향을 **곡선 내 샘플링**으로 배치합니다.  
  (false면 반대로 배치)
- 이 격자를 NURBS 표면의 CV로 복사하고, 균일 클램프 knot를 생성합니다.

---

## ✨ 함수 시그니처

```cpp
bool ON_LoftCurvesSimple(
  const std::vector<const ON_Curve*>& curves, // 단면 곡선들 (>=2)
  int   samples_u,                            // 각 곡선에서 u 샘플 개수 (>=2 권장)
  bool  sweep_u,                              // true: u=곡선 인덱스, v=샘플
  int   deg_sweep,                            // u방향 차수
  ON_NurbsSurface& srf                        // 결과 표면
);
```

---

## 🔧 구현 (그대로 붙여 넣어 사용)

```cpp
#include <vector>
#include <algorithm> // std::min, std::max, std::clamp
// OpenNURBS 헤더는 환경에 맞게 포함
// #include "opennurbs.h"

bool ON_LoftCurvesSimple(
  const std::vector<const ON_Curve*>& curves,
  int samples_u, 
  bool sweep_u,
  int deg_sweep, 
  ON_NurbsSurface& srf)
{
  if (curves.size() < 2) return false;

  // 공통 도메인 (모든 곡선이 동일 도메인이라 가정)
  double cu0, cu1;
  curves[0]->GetDomain(&cu0, &cu1);

  const int W = static_cast<int>(curves.size());
  const int H = std::max(4, samples_u);

  // W x H 포인트 그리드
  std::vector<ON_3dPoint> grid(W * H);
  for (int j = 0; j < H; ++j)
  {
    const double t = cu0 + (cu1 - cu0) * (double)j / (H - 1);
    for (int i = 0; i < W; ++i)
      grid[j * W + i] = curves[i]->PointAt(t);
  }

  // u,v 배치: sweep_u=true → u=W, v=H
  int nu = sweep_u ? W : H;
  int nv = sweep_u ? H : W;

  auto at = [&](int iu, int iv) -> const ON_3dPoint&
  {
    return sweep_u ? grid[iv * W + iu] : grid[iu * W + iv];
  };

  // 차수 결정
  const int du = std::clamp(deg_sweep, 1, nu - 1);
  const int dv = std::min(3, nv - 1); // v는 적당히 3차 이하

  // 표면 생성 (dim=3, non-rational)
  srf = ON_NurbsSurface(3, false, du + 1, dv + 1, nu, nv);

  // CV 복사
  for (int iv = 0; iv < nv; ++iv)
    for (int iu = 0; iu < nu; ++iu)
      srf.SetCV(iu, iv, at(iu, iv));

  // 균일 클램프 knot
  srf.MakeClampedUniformKnotVector(0, 1.0);
  srf.MakeClampedUniformKnotVector(1, 1.0);

  ON_TextLog log;
  return srf.IsValid(&log);
}
```

---

## ➕ 테스트용 헬퍼 & 예제 `main()`

```cpp
// 타원 곡선 생성 (유리 NURBS)
static ON_NurbsCurve* MakeEllipse(
  double rx, double ry,
  const ON_3dPoint& center,
  const ON_3dVector& normal)
{
  ON_Plane pln(center, normal);
  ON_Ellipse E(pln, rx, ry);
  auto* c = new ON_NurbsCurve();
  if (!E.GetNurbForm(*c)) { delete c; return nullptr; }
  return c;
}

int main()
{
  ON::Begin();
  ON_TextLog log;

  ON_SimpleArray<ON_NurbsCurve*> owned;
  std::vector<const ON_Curve*> sections;

  // 단면 곡선 3~4개
  auto* c0 = MakeEllipse(5.0, 2.0, ON_3dPoint(0,0,0), ON_3dVector::ZAxis);
  auto* c1 = MakeEllipse(9.0, 4.5, ON_3dPoint(0,0,2), ON_3dVector::ZAxis);
  auto* c2 = MakeEllipse(2.5, 1.0, ON_3dPoint(0,0,4), ON_3dVector::ZAxis);
  auto* c3 = MakeEllipse(2.5, 2.0, ON_3dPoint(0,0,6), ON_3dVector::ZAxis);

  if (!c0 || !c1 || !c2 || !c3) {
    log.Print("Ellipse creation failed.\n");
    if (c0) delete c0; if (c1) delete c1; if (c2) delete c2; if (c3) delete c3;
    ON::End(); return 1;
  }
  owned.Append(c0); owned.Append(c1); owned.Append(c2); owned.Append(c3);

  // 이번 데모는 3개만 사용
  sections = { c0, c1, c2 };

  ON_NurbsSurface srf;
  const int  samples_u = 9;    // 곡선 내 샘플 수
  const bool sweep_u   = true; // u=곡선 인덱스
  const int  deg_u     = 3;    // u 차수

  const bool ok = ON_LoftCurvesSimple(sections, samples_u, sweep_u, deg_u, srf);
  if (!ok) {
    log.Print("Loft failed.\n");
    for (int i = 0; i < owned.Count(); ++i) delete owned[i];
    ON::End(); return 1;
  }

  // 간단 메시 생성 (시각화/내보내기용)
  //ON_Mesh mesh;
  //ON_MeshParameters mp; mp.SetGridMaxCount(20);
  //srf.CreateMesh(mp, &mesh);

  // 필요 시 내보내기 (사용 환경에 맞게 구현/교체)
  // ON_ExportBDF bdf;
  // bdf.Run(L"D:\\Temp\\Test1.bdf", &mesh);

  for (int i = 0; i < owned.Count(); ++i) delete owned[i];
  ON::End();
  return 0;
}
```

---

## 📸 결과 이미지 (여기에 스크린샷 넣어주세요)

> 아래 경로/파일명을 프로젝트에 맞게 바꿔 사용하세요.


![Loft demo](/image/loft.jpg)


---


## 🧭 파라미터 가이드

- `samples_u`  
  각 단면 곡선에서 샘플링할 `u` 개수. 클수록 v방향 해상도 증가.
- `sweep_u`  
  `true`면 `u=곡선 인덱스`, `v=샘플`. (여러 섹션을 u로 “휩쓴다”는 느낌)  
  `false`면 반대 배치.
- `deg_sweep`  
  `u` 방향 차수. `1..(nu-1)` 범위 내에서 `std::clamp`.

---

## 🏗️ 빌드

- **전제**: OpenNURBS 헤더/라이브러리 준비
- **권장**: C++17 이상

### MSVC
```bat
cl /std:c++17 /O2 demo.cpp opennurbs_publiclib.lib
```

### g++ / clang++
```bash
g++ -std=c++17 -O2 demo.cpp -lopennurbs -o loft_demo
```

> 라이브러리 이름/경로는 OpenNURBS 빌드 방식에 따라 다릅니다.

---

## 📝 메모 & 팁

- 모든 곡선이 **동일 도메인**을 갖는다고 가정합니다. 다르면 `Reparameterize()` 등으로 맞추세요.
- 현재 구현은 **비유리 표면**(rational=false)을 생성합니다. 필요하면 가중치 처리 로직을 추가할 수 있어요.
- 메시 해상도는 `ON_MeshParameters` 로 조정하세요.

---

## 📄 라이선스

원하는 라이선스를 프로젝트 루트 `LICENSE` 파일로 추가하세요. (예: MIT)

즐거운 서피싱! 🏄‍♂️

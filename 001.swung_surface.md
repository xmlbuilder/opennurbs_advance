# 🌀 Swung Surface from Two NURBS Curves (OpenNURBS)

Swung surface는 회전체(surface of revolution)의 일반화로, **프로파일 곡선**을 축 주위로 회전시키되 회전 각도와 스케일을 **트래젝터리(trajectory) 곡선**이 지배하도록 만든 곡면입니다. 
직관적으로는, 수직 방향(예: z-축)에 대한 “프로파일의 실루엣”을 유지하면서 수평 단면은 트래젝터리 곡선의 모양을 따르도록 ‘휘두르는(swing)’ 과정으로 이해할 수 있습니다.

---

## 1) 구성 요소

- 프로파일 곡선( xz-평면 ):  
  $$\beta(v) = (x(v),\quad0,\quadz(v)),\quadx(v) \ge 0$$

- 트래젝터리 곡선( xy-평면 ):  
  $$\gamma(u) = (a(u), b(u))$$  
  (편의상 극좌표 $$\gamma(u)=(\rho(u)\cos\theta(u), \rho(u)\sin\theta(u))$$ 로도 표기 가능)

## 2) 기본 파라메트릭 방정식

$$
S(u,v) = (x(v)a(u),\quadx(v)b(u),\quadz(v))
$$

또는 극좌표 형태로

$$
S(u,v) = (\rho(u)x(v)\cos\theta(u),\quad\rho(u)x(v)\sin\theta(u),\quadz(v))
$$

## 3) 미분량 및 법선

편미분:

$$
S_u = (x(v)a'(u),\quad x(v)b'(u),\quad 0), \quad 
S_v = (x'(v)a(u),\quad  x'(v)b(u),\quad  z'(v))
$$

법선 벡터:

$$
S_u \times S_v = (x b' z',\quad  -x a' z',\quad  x x'(a'b - b'a))
$$

제1기본형식:

$$
E = x(v)^2(a'(u)^2+b'(u)^2), \quad 
F = x(v)x'(v)(a a'+ b b'), \quad 
G = x'(v)^2(a^2+b^2)+z'(v)^2
$$

## 4) 특수화

- **회전체**: $$a(u)=\cos u, b(u)=\sin u$$
- **튜브**: $$x(v)=R, z(v)=v$$ 등

## 5) NURBS 기반 구현

동차 좌표 제어점:

$$
C_{i,j} = (x_j a_i, x_j b_i, z_j, w^{(\gamma)}_i w^{(\beta)}_j)
$$

즉, 제어망을 텐서곱으로 구성.

## 6) 요약

- 기본식: $$S(u,v) = (x(v)a(u), x(v)b(u), z(v))$$
- 프로파일 곡선 → 수직 형상
- 트래젝터리 곡선 → 수평 단면
- NURBS에서는 제어점 곱으로 구현 가능

---


## ✨ 단순한 형태로 구현 

Given:
- `profileXZ(u) = (xp(u), 0, zp(u))` (NURBS, dim=3)
- `trajXY(v)    = (xt(v), yt(v), 0)` (NURBS, dim=3)

we build a surface `Q(u,v)` whose control points follow the **swung** rule:

```
x(u,v) = α * xp(u) * xt(v)
y(u,v) = α * xp(u) * yt(v)
z(u,v) = zp(u)
```

If any input curve is **rational**, the surface is rational and the weight is
`wQ = wP * wT`. All knots/degree are copied along U/V directions.

---

## 📦 전체 코드

```cpp
bool ON_MakeSwungSurface(
  const ON_NurbsCurve& profileXZ,
  const ON_NurbsCurve& trajXY,
  double alpha,
  ON_NurbsSurface& out_srf)
{
  if (profileXZ.Dimension() != 3 || trajXY.Dimension() != 3) return false;

  const int nu = profileXZ.CVCount();
  const int nv = trajXY.CVCount();
  if (nu < 2 || nv < 2) return false;

  const int pu = profileXZ.Degree();
  const int pv = trajXY.Degree();

  const int u_knot_count = profileXZ.KnotCount(); // = nu + (pu+1) - 2
  const int v_knot_count = trajXY.KnotCount();    // = nv + (pv+1) - 2

  const bool rational = profileXZ.IsRational() || trajXY.IsRational();

  // create (dim=3)
  out_srf.Create(3, rational, pu + 1, pv + 1, nu, nv);

  // copy knots
  for (int i = 0; i < u_knot_count; ++i)
    out_srf.SetKnot(0, i, profileXZ.Knot(i));
  for (int j = 0; j < v_knot_count; ++j)
    out_srf.SetKnot(1, j, trajXY.Knot(j));

  // set CVs
  for (int i = 0; i < nu; ++i)
  {
    ON_4dPoint Pw = profileXZ.ControlPoint(i);
    const double xp = Pw.x / (Pw.w ? Pw.w : 1.0);
    const double zp = Pw.z / (Pw.w ? Pw.w : 1.0);
    const double wP = (Pw.w > 0.0 ? Pw.w : 1.0);

    for (int j = 0; j < nv; ++j)
    {
      ON_4dPoint Tw = trajXY.ControlPoint(j);
      const double xt = Tw.x / (Tw.w ? Tw.w : 1.0);
      const double yt = Tw.y / (Tw.w ? Tw.w : 1.0);
      const double wT = (Tw.w > 0.0 ? Tw.w : 1.0);

      const double xq = alpha * xp * xt;
      const double yq = alpha * xp * yt;
      const double zq = zp;

      if (rational)
      {
        const double wQ = wP * wT;
        out_srf.SetCV(i, j, ON_4dPoint(xq * wQ, yq * wQ, zq * wQ, wQ));
      }
      else
      {
        out_srf.SetCV(i, j, ON_3dPoint(xq, yq, zq));
      }
    }
  }
  return out_srf.IsValid();
}
```

---

## 🧪 샘플 코드 (profile + quarter circle)

```cpp
// XZ profile
static ON_NurbsCurve MakeProfileXZ()
{
  ON_NurbsCurve c;
  c.Create(3, false, 3, 3); // dim=3, non-rational, degree=3, 3 CVs
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);
  c.SetCV(0, ON_3dPoint(1.0, 0.0, 0.0));
  c.SetCV(1, ON_3dPoint(0.6, 0.0, 1.0));
  c.SetCV(2, ON_3dPoint(0.8, 0.0, 2.0));
  return c;
}

// XY 90° arc (rational)
static ON_NurbsCurve MakeQuarterArcXY()
{
  const double s2 = ::sqrt(2.0);
  const double w  = s2 * 0.5; // cos(45°)

  ON_NurbsCurve c;
  c.Create(3, true, 3, 3);
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);

  c.SetCV(0, ON_4dPoint(1.0, 0.0, 0.0, 1.0));
  c.SetCV(1, ON_4dPoint((s2*0.5)*w, (s2*0.5)*w, 0.0, w));
  c.SetCV(2, ON_4dPoint(0.0, 1.0, 0.0, 1.0));
  return c;
}
```

### `main()`
```cpp
int main()
{
  ON::Begin();
  ON_NurbsCurve profile = MakeProfileXZ();
  ON_NurbsCurve traj    = MakeQuarterArcXY();
  ON_NurbsSurface srf;

  const double alpha = 1.0;
  if (!ON_MakeSwungSurface(profile, traj, alpha, srf))
    return 1;

  // quick sanity
  ON_TextLog log;
  log.Print("dim=%d, degU=%d, degV=%d, rational=%d\n",
            srf.Dimension(), srf.Degree(0), srf.Degree(1), srf.IsRational());

  // (Optional) create a coarse mesh
  //  ON_Mesh mesh;
  //  ON_MeshParameters mp; mp.SetGridMaxCount(20);
  //  srf.CreateMesh(mp, &mesh);

  // (Optional) export
  // ON_ExportBDF bdf; bdf.Run(L\"swung.bdf\", &mesh);

  ON::End();
  return 0;
}
```

## 출력 메시지
```
Swung surface created.
  dim = 3, rational = 1
  degU = 2, degV = 2
  CV count U x V = 3 x 3
  CV(0,0) = (1.000000, 0.000000, 0.000000; w=1.000000)
  CV(0,1) = (0.707107, 0.707107, 0.000000; w=0.707107)
  CV(0,2) = (0.000000, 1.000000, 0.000000; w=1.000000)
  CV(1,0) = (0.600000, 0.000000, 1.000000; w=1.000000)
  CV(1,1) = (0.424264, 0.424264, 1.000000; w=0.707107)
  CV(1,2) = (0.000000, 0.600000, 1.000000; w=1.000000)
  CV(2,0) = (0.800000, 0.000000, 2.000000; w=1.000000)
  CV(2,1) = (0.565685, 0.565685, 2.000000; w=0.707107)
  CV(2,2) = (0.000000, 0.800000, 2.000000; w=1.000000)
```
![Swung surface demo](/image/swung.jpg)

---

## 🔧 Build

- **Prerequisite**: OpenNURBS headers/libs.
- **C++17** (or later) recommended.

### MSVC
```
cl /std:c++17 /O2 demo.cpp opennurbs_publiclib.lib
```

### g++/clang++
```
g++ -std=c++17 -O2 demo.cpp -lopennurbs -o swung_demo
```

> 실제 링크 옵션/라이브러리 이름은 OpenNURBS 빌드 환경에 따라 다릅니다.

---

## 📝 Notes & Tips

- 입력 곡선이 **2개 모두 유리**여도 정상 동작합니다. 표면 weight는 \( w_Q = w_P w_T \).
- `alpha`로 XY 스윙의 **스케일**을 제어합니다.
- `out_srf.IsValid()`로 생성 결과를 검증할 수 있습니다.

---

## 📄 License

Add your project license here (e.g., MIT).


# Ellipse‑based Arc → NURBS (OpenNURBS)

**개요.**  
타원(또는 타원호)을 **원(또는 원호) NURBS**로 먼저 구성한 뒤, **평면 로컬 좌표에서 Y성분만 선형 스케일**하여 **정확한 유리 NURBS 타원(호)**를 만드는 절차입니다.  
OpenNURBS의 `ON_Arc::GetNurbForm` 표준 루틴을 활용해 **간단·안정**하게 구현할 수 있습니다.

---

## 핵심 수식 (SVG)

타원 파라미터 \(a\)에서 점:  
![ellipse-point](https://latex.codecogs.com/svg.latex?P(a)=C+r_1\cos{a}\,X+r_2\sin{a}\,Y)

선 \(L(s)=C+sX\) (X축) 직투영으로 “원각”:  
![theta-map](https://latex.codecogs.com/svg.latex?%5Ctheta(a)=%5Carccos%28%5Cmathrm%7Bclamp%7D%28%28P(a)-C%29%5Ccdot%20X%2Fr_1%2C-1%2C1%29%29)

> 구현에서는 `a>180°`일 때 분지 보정: $$\(\theta \leftarrow 360° - \theta\)$$.

---

## 알고리즘 요약

1. 평면 축 정규화 및 직교화  
2. 타원 시작/끝 각(as, ae)을 [0,360)로 정규화  
3. 위 수식으로 타원각 → **원각** 매핑 (시작·끝)  
4. 평면 (C,X,Y), 반지름 r1의 **원/원호 NURBS** 생성  
5. 모든 CV를 로컬 좌표로 변환 후 **Y성분만 r2/r1 배 스케일** → 월드 좌표 복원  
6. 유리성(가중치) 그대로 유지 → 결과는 **유리 타원(호) NURBS**

---

## API

```cpp
bool ON_MakeEllipseOrArcNurbs(
  ON_3dPoint  C,
  ON_3dVector X,
  ON_3dVector Y,
  double      r1,
  double      r2,
  double      as_deg,
  double      ae_deg,
  ON_NurbsCurve& out
);
```

---

## 단위 테스트 코드

```cpp
#include "opennurbs.h"
#include <cstdio>
#include <vector>
#include <cmath>
#include <algorithm>

// Orthonormalization helper
static void OrthonormalizeXY(ON_3dVector& X, ON_3dVector& Y, ON_3dVector& Z)
{
  X.Unitize();
  Y = Y - ON_DotProduct(X, Y) * X;
  Y.Unitize();
  Z = ON_CrossProduct(X, Y);
  Z.Unitize();
}

static ON_3dPoint EllipsePointDeg(
  const ON_3dPoint& C,
  const ON_3dVector& Xin,
  const ON_3dVector& Yin,
  double r1, double r2,
  double a_deg)
{
  ON_3dVector X = Xin, Y = Yin, Z;
  OrthonormalizeXY(X, Y, Z);
  const double a = ON_DegToRad(a_deg);
  return C + (r1 * std::cos(a)) * X + (r2 * std::sin(a)) * Y;
}

// 사용자 구현
bool ON_MakeEllipseOrArcNurbs(
  ON_3dPoint C, ON_3dVector X, ON_3dVector Y,
  double r1, double r2,
  double as_deg, double ae_deg,
  ON_NurbsCurve& out);

static bool CurveClosestDist(
  const ON_Curve& crv,
  const ON_3dPoint& Q,
  double& out_t,
  double& out_dist)
{
  double t;
  if (!crv.GetClosestPoint(Q, &t)) return false;
  ON_3dPoint P = crv.PointAt(t);
  out_t = t;
  out_dist = P.DistanceTo(Q);
  return true;
}

#define EXPECT_TRUE(cond, msg) \
  do { if (!(cond)) { std::printf("[FAIL] %s\n", msg); return false; } } while(0)
#define EXPECT_LE(x, y, msg) \
  do { if (!((x) <= (y))) { std::printf("[FAIL] %s (%.9g > %.9g)\n", msg, (double)(x), (double)(y)); return false; } } while(0)

// --- Tests ---
static bool Test_FullEllipse()
{
  ON_3dPoint C(0,0,0);
  ON_3dVector X(1,0,0), Y(0,1,0);
  ON_NurbsCurve nc;
  bool ok = ON_MakeEllipseOrArcNurbs(C,X,Y,20,10,0,0,nc);
  EXPECT_TRUE(ok,"ellipse build");
  EXPECT_TRUE(nc.IsValid(),"nurbs valid");

  const double tol = 1e-6 * 20.0;
  for(int i=0;i<90;++i){
    double a = 360.0*i/89;
    ON_3dPoint P = EllipsePointDeg(C,X,Y,20,10,a);
    double t,d; EXPECT_TRUE(CurveClosestDist(nc,P,t,d),"closest point");
    EXPECT_LE(d,tol,"point within tol");
  }
  return true;
}

int main(){
  ON::Begin();
  int pass=0, fail=0;
  if(Test_FullEllipse()){pass++;}else{fail++;}
  std::printf("Summary: pass=%d fail=%d\n",pass,fail);
  ON::End();
  return fail==0?0:1;
}
```

---

## 검증 체크리스트

- `nc.IsValid()==true`  
- 100~200 샘플 각도에서 최근접 오차 ≤ `1e-6 * max(r1,r2)`  
- 비직교 입력 축, 임의 평면에서도 통과  
- 부분호도 통과  
- 잘못된 입력(r≤0)에서 실패 반환

---

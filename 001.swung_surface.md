# ğŸŒ€ Swung Surface from Two NURBS Curves (OpenNURBS)

Swung surfaceëŠ” íšŒì „ì²´(surface of revolution)ì˜ ì¼ë°˜í™”ë¡œ, **í”„ë¡œíŒŒì¼ ê³¡ì„ **ì„ ì¶• ì£¼ìœ„ë¡œ íšŒì „ì‹œí‚¤ë˜ íšŒì „ ê°ë„ì™€ ìŠ¤ì¼€ì¼ì„ **íŠ¸ë˜ì í„°ë¦¬(trajectory) ê³¡ì„ **ì´ ì§€ë°°í•˜ë„ë¡ ë§Œë“  ê³¡ë©´ì…ë‹ˆë‹¤. 
ì§ê´€ì ìœ¼ë¡œëŠ”, ìˆ˜ì§ ë°©í–¥(ì˜ˆ: z-ì¶•)ì— ëŒ€í•œ â€œí”„ë¡œíŒŒì¼ì˜ ì‹¤ë£¨ì—£â€ì„ ìœ ì§€í•˜ë©´ì„œ ìˆ˜í‰ ë‹¨ë©´ì€ íŠ¸ë˜ì í„°ë¦¬ ê³¡ì„ ì˜ ëª¨ì–‘ì„ ë”°ë¥´ë„ë¡ â€˜íœ˜ë‘ë¥´ëŠ”(swing)â€™ ê³¼ì •ìœ¼ë¡œ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## 1) êµ¬ì„± ìš”ì†Œ

- í”„ë¡œíŒŒì¼ ê³¡ì„ ( xz-í‰ë©´ ):  
  $$\beta(v) = (x(v),\quad0,\quadz(v)),\quadx(v) \ge 0$$

- íŠ¸ë˜ì í„°ë¦¬ ê³¡ì„ ( xy-í‰ë©´ ):  
  $$\gamma(u) = (a(u), b(u))$$  
  (í¸ì˜ìƒ ê·¹ì¢Œí‘œ $$\gamma(u)=(\rho(u)\cos\theta(u), \rho(u)\sin\theta(u))$$ ë¡œë„ í‘œê¸° ê°€ëŠ¥)

## 2) ê¸°ë³¸ íŒŒë¼ë©”íŠ¸ë¦­ ë°©ì •ì‹

$$
S(u,v) = (x(v)a(u),\quadx(v)b(u),\quadz(v))
$$

ë˜ëŠ” ê·¹ì¢Œí‘œ í˜•íƒœë¡œ

$$
S(u,v) = (\rho(u)x(v)\cos\theta(u),\quad\rho(u)x(v)\sin\theta(u),\quadz(v))
$$

## 3) ë¯¸ë¶„ëŸ‰ ë° ë²•ì„ 

í¸ë¯¸ë¶„:

$$
S_u = (x(v)a'(u),\quad x(v)b'(u),\quad 0), \quad 
S_v = (x'(v)a(u),\quad  x'(v)b(u),\quad  z'(v))
$$

ë²•ì„  ë²¡í„°:

$$
S_u \times S_v = (x b' z',\quad  -x a' z',\quad  x x'(a'b - b'a))
$$

ì œ1ê¸°ë³¸í˜•ì‹:

$$
E = x(v)^2(a'(u)^2+b'(u)^2), \quad 
F = x(v)x'(v)(a a'+ b b'), \quad 
G = x'(v)^2(a^2+b^2)+z'(v)^2
$$

## 4) íŠ¹ìˆ˜í™”

- **íšŒì „ì²´**: $$a(u)=\cos u, b(u)=\sin u$$
- **íŠœë¸Œ**: $$x(v)=R, z(v)=v$$ ë“±

## 5) NURBS ê¸°ë°˜ êµ¬í˜„

ë™ì°¨ ì¢Œí‘œ ì œì–´ì :

$$
C_{i,j} = (x_j a_i, x_j b_i, z_j, w^{(\gamma)}_i w^{(\beta)}_j)
$$

ì¦‰, ì œì–´ë§ì„ í…ì„œê³±ìœ¼ë¡œ êµ¬ì„±.

## 6) ìš”ì•½

- ê¸°ë³¸ì‹: $$S(u,v) = (x(v)a(u), x(v)b(u), z(v))$$
- í”„ë¡œíŒŒì¼ ê³¡ì„  â†’ ìˆ˜ì§ í˜•ìƒ
- íŠ¸ë˜ì í„°ë¦¬ ê³¡ì„  â†’ ìˆ˜í‰ ë‹¨ë©´
- NURBSì—ì„œëŠ” ì œì–´ì  ê³±ìœ¼ë¡œ êµ¬í˜„ ê°€ëŠ¥

---


## âœ¨ ë‹¨ìˆœí•œ í˜•íƒœë¡œ êµ¬í˜„ 

Given:
- `profileXZ(u) = (xp(u), 0, zp(u))` (NURBS, dim=3)
- `trajXY(v)    = (xt(v), yt(v), 0)` (NURBS, dim=3)

we build a surface `Q(u,v)` whose control points follow the **swung** rule:

```
x(u,v) = Î± * xp(u) * xt(v)
y(u,v) = Î± * xp(u) * yt(v)
z(u,v) = zp(u)
```

If any input curve is **rational**, the surface is rational and the weight is
`wQ = wP * wT`. All knots/degree are copied along U/V directions.

---

## ğŸ“¦ ì „ì²´ ì½”ë“œ

```cpp
bool ON_MakeSwungSurface(
  const ON_NurbsCurve& profileXZ,
  const ON_NurbsCurve& trajXY,
  double alpha,
  ON_NurbsSurface& out_srf)
{
  if (profileXZ.Dimension() != 3 || trajXY.Dimension() != 3) return false;

  const int nu = profileXZ.CVCount();
  const int nv = trajXY.CVCount();
  if (nu < 2 || nv < 2) return false;

  const int pu = profileXZ.Degree();
  const int pv = trajXY.Degree();

  const int u_knot_count = profileXZ.KnotCount(); // = nu + (pu+1) - 2
  const int v_knot_count = trajXY.KnotCount();    // = nv + (pv+1) - 2

  const bool rational = profileXZ.IsRational() || trajXY.IsRational();

  // create (dim=3)
  out_srf.Create(3, rational, pu + 1, pv + 1, nu, nv);

  // copy knots
  for (int i = 0; i < u_knot_count; ++i)
    out_srf.SetKnot(0, i, profileXZ.Knot(i));
  for (int j = 0; j < v_knot_count; ++j)
    out_srf.SetKnot(1, j, trajXY.Knot(j));

  // set CVs
  for (int i = 0; i < nu; ++i)
  {
    ON_4dPoint Pw = profileXZ.ControlPoint(i);
    const double xp = Pw.x / (Pw.w ? Pw.w : 1.0);
    const double zp = Pw.z / (Pw.w ? Pw.w : 1.0);
    const double wP = (Pw.w > 0.0 ? Pw.w : 1.0);

    for (int j = 0; j < nv; ++j)
    {
      ON_4dPoint Tw = trajXY.ControlPoint(j);
      const double xt = Tw.x / (Tw.w ? Tw.w : 1.0);
      const double yt = Tw.y / (Tw.w ? Tw.w : 1.0);
      const double wT = (Tw.w > 0.0 ? Tw.w : 1.0);

      const double xq = alpha * xp * xt;
      const double yq = alpha * xp * yt;
      const double zq = zp;

      if (rational)
      {
        const double wQ = wP * wT;
        out_srf.SetCV(i, j, ON_4dPoint(xq * wQ, yq * wQ, zq * wQ, wQ));
      }
      else
      {
        out_srf.SetCV(i, j, ON_3dPoint(xq, yq, zq));
      }
    }
  }
  return out_srf.IsValid();
}
```

---

## ğŸ§ª ìƒ˜í”Œ ì½”ë“œ (profile + quarter circle)

```cpp
// XZ profile
static ON_NurbsCurve MakeProfileXZ()
{
  ON_NurbsCurve c;
  c.Create(3, false, 3, 3); // dim=3, non-rational, degree=3, 3 CVs
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);
  c.SetCV(0, ON_3dPoint(1.0, 0.0, 0.0));
  c.SetCV(1, ON_3dPoint(0.6, 0.0, 1.0));
  c.SetCV(2, ON_3dPoint(0.8, 0.0, 2.0));
  return c;
}

// XY 90Â° arc (rational)
static ON_NurbsCurve MakeQuarterArcXY()
{
  const double s2 = ::sqrt(2.0);
  const double w  = s2 * 0.5; // cos(45Â°)

  ON_NurbsCurve c;
  c.Create(3, true, 3, 3);
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);

  c.SetCV(0, ON_4dPoint(1.0, 0.0, 0.0, 1.0));
  c.SetCV(1, ON_4dPoint((s2*0.5)*w, (s2*0.5)*w, 0.0, w));
  c.SetCV(2, ON_4dPoint(0.0, 1.0, 0.0, 1.0));
  return c;
}
```

### `main()`
```cpp
int main()
{
  ON::Begin();
  ON_NurbsCurve profile = MakeProfileXZ();
  ON_NurbsCurve traj    = MakeQuarterArcXY();
  ON_NurbsSurface srf;

  const double alpha = 1.0;
  if (!ON_MakeSwungSurface(profile, traj, alpha, srf))
    return 1;

  // quick sanity
  ON_TextLog log;
  log.Print("dim=%d, degU=%d, degV=%d, rational=%d\n",
            srf.Dimension(), srf.Degree(0), srf.Degree(1), srf.IsRational());

  // (Optional) create a coarse mesh
  //  ON_Mesh mesh;
  //  ON_MeshParameters mp; mp.SetGridMaxCount(20);
  //  srf.CreateMesh(mp, &mesh);

  // (Optional) export
  // ON_ExportBDF bdf; bdf.Run(L\"swung.bdf\", &mesh);

  ON::End();
  return 0;
}
```

## ì¶œë ¥ ë©”ì‹œì§€
```
Swung surface created.
  dim = 3, rational = 1
  degU = 2, degV = 2
  CV count U x V = 3 x 3
  CV(0,0) = (1.000000, 0.000000, 0.000000; w=1.000000)
  CV(0,1) = (0.707107, 0.707107, 0.000000; w=0.707107)
  CV(0,2) = (0.000000, 1.000000, 0.000000; w=1.000000)
  CV(1,0) = (0.600000, 0.000000, 1.000000; w=1.000000)
  CV(1,1) = (0.424264, 0.424264, 1.000000; w=0.707107)
  CV(1,2) = (0.000000, 0.600000, 1.000000; w=1.000000)
  CV(2,0) = (0.800000, 0.000000, 2.000000; w=1.000000)
  CV(2,1) = (0.565685, 0.565685, 2.000000; w=0.707107)
  CV(2,2) = (0.000000, 0.800000, 2.000000; w=1.000000)
```
![Swung surface demo](/image/swung.jpg)

---

## ğŸ”§ Build

- **Prerequisite**: OpenNURBS headers/libs.
- **C++17** (or later) recommended.

### MSVC
```
cl /std:c++17 /O2 demo.cpp opennurbs_publiclib.lib
```

### g++/clang++
```
g++ -std=c++17 -O2 demo.cpp -lopennurbs -o swung_demo
```

> ì‹¤ì œ ë§í¬ ì˜µì…˜/ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ë¦„ì€ OpenNURBS ë¹Œë“œ í™˜ê²½ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤.

---

## ğŸ“ Notes & Tips

- ì…ë ¥ ê³¡ì„ ì´ **2ê°œ ëª¨ë‘ ìœ ë¦¬**ì—¬ë„ ì •ìƒ ë™ì‘í•©ë‹ˆë‹¤. í‘œë©´ weightëŠ” \( w_Q = w_P w_T \).
- `alpha`ë¡œ XY ìŠ¤ìœ™ì˜ **ìŠ¤ì¼€ì¼**ì„ ì œì–´í•©ë‹ˆë‹¤.
- `out_srf.IsValid()`ë¡œ ìƒì„± ê²°ê³¼ë¥¼ ê²€ì¦í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ğŸ“„ License

Add your project license here (e.g., MIT).

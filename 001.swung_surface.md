# 🌀 Swung Surface from Two NURBS Curves (OpenNURBS)

> **Swung surface** generator that builds a NURBS surface from
> - a **profile** curve in the **XZ** plane, and
> - a **trajectory** curve in the **XY** plane,  
> with an optional scale parameter `alpha`.

![Swung surface demo](/image/swung.jpg)

---

## ✨ What this does

Given:
- `profileXZ(u) = (xp(u), 0, zp(u))` (NURBS, dim=3)
- `trajXY(v)    = (xt(v), yt(v), 0)` (NURBS, dim=3)

we build a surface `Q(u,v)` whose control points follow the **swung** rule:

```
x(u,v) = α * xp(u) * xt(v)
y(u,v) = α * xp(u) * yt(v)
z(u,v) = zp(u)
```

If any input curve is **rational**, the surface is rational and the weight is
`wQ = wP * wT`. All knots/degree are copied along U/V directions.

---

## 📦 Core function

```cpp
bool ON_MakeSwungSurface(
  const ON_NurbsCurve& profileXZ,
  const ON_NurbsCurve& trajXY,
  double alpha,
  ON_NurbsSurface& out_srf)
{
  if (profileXZ.Dimension() != 3 || trajXY.Dimension() != 3) return false;

  const int nu = profileXZ.CVCount();
  const int nv = trajXY.CVCount();
  if (nu < 2 || nv < 2) return false;

  const int pu = profileXZ.Degree();
  const int pv = trajXY.Degree();

  const int u_knot_count = profileXZ.KnotCount(); // = nu + (pu+1) - 2
  const int v_knot_count = trajXY.KnotCount();    // = nv + (pv+1) - 2

  const bool rational = profileXZ.IsRational() || trajXY.IsRational();

  // create (dim=3)
  out_srf.Create(3, rational, pu + 1, pv + 1, nu, nv);

  // copy knots
  for (int i = 0; i < u_knot_count; ++i)
    out_srf.SetKnot(0, i, profileXZ.Knot(i));
  for (int j = 0; j < v_knot_count; ++j)
    out_srf.SetKnot(1, j, trajXY.Knot(j));

  // set CVs
  for (int i = 0; i < nu; ++i)
  {
    ON_4dPoint Pw = profileXZ.ControlPoint(i);
    const double xp = Pw.x / (Pw.w ? Pw.w : 1.0);
    const double zp = Pw.z / (Pw.w ? Pw.w : 1.0);
    const double wP = (Pw.w > 0.0 ? Pw.w : 1.0);

    for (int j = 0; j < nv; ++j)
    {
      ON_4dPoint Tw = trajXY.ControlPoint(j);
      const double xt = Tw.x / (Tw.w ? Tw.w : 1.0);
      const double yt = Tw.y / (Tw.w ? Tw.w : 1.0);
      const double wT = (Tw.w > 0.0 ? Tw.w : 1.0);

      const double xq = alpha * xp * xt;
      const double yq = alpha * xp * yt;
      const double zq = zp;

      if (rational)
      {
        const double wQ = wP * wT;
        out_srf.SetCV(i, j, ON_4dPoint(xq * wQ, yq * wQ, zq * wQ, wQ));
      }
      else
      {
        out_srf.SetCV(i, j, ON_3dPoint(xq, yq, zq));
      }
    }
  }
  return out_srf.IsValid();
}
```

---

## 🧪 Minimal demo (profile + quarter circle)

```cpp
// XZ profile
static ON_NurbsCurve MakeProfileXZ()
{
  ON_NurbsCurve c;
  c.Create(3, false, 3, 3); // dim=3, non-rational, degree=3, 3 CVs
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);
  c.SetCV(0, ON_3dPoint(1.0, 0.0, 0.0));
  c.SetCV(1, ON_3dPoint(0.6, 0.0, 1.0));
  c.SetCV(2, ON_3dPoint(0.8, 0.0, 2.0));
  return c;
}

// XY 90° arc (rational)
static ON_NurbsCurve MakeQuarterArcXY()
{
  const double s2 = ::sqrt(2.0);
  const double w  = s2 * 0.5; // cos(45°)

  ON_NurbsCurve c;
  c.Create(3, true, 3, 3);
  c.SetKnot(0,0.0); c.SetKnot(1,0.0);
  c.SetKnot(2,1.0); c.SetKnot(3,1.0);

  c.SetCV(0, ON_4dPoint(1.0, 0.0, 0.0, 1.0));
  c.SetCV(1, ON_4dPoint((s2*0.5)*w, (s2*0.5)*w, 0.0, w));
  c.SetCV(2, ON_4dPoint(0.0, 1.0, 0.0, 1.0));
  return c;
}
```

### `main()` (mesh export 예시는 생략 가능)
```cpp
int main()
{
  ON::Begin();
  ON_NurbsCurve profile = MakeProfileXZ();
  ON_NurbsCurve traj    = MakeQuarterArcXY();
  ON_NurbsSurface srf;

  const double alpha = 1.0;
  if (!ON_MakeSwungSurface(profile, traj, alpha, srf))
    return 1;

  // quick sanity
  ON_TextLog log;
  log.Print("dim=%d, degU=%d, degV=%d, rational=%d\n",
            srf.Dimension(), srf.Degree(0), srf.Degree(1), srf.IsRational());

  // (Optional) create a coarse mesh
  //  ON_Mesh mesh;
  //  ON_MeshParameters mp; mp.SetGridMaxCount(20);
  //  srf.CreateMesh(mp, &mesh);

  // (Optional) export
  // ON_ExportBDF bdf; bdf.Run(L\"swung.bdf\", &mesh);

  ON::End();
  return 0;
}
```

## 출력 메시지
```
Swung surface created.
  dim = 3, rational = 1
  degU = 2, degV = 2
  CV count U x V = 3 x 3
  CV(0,0) = (1.000000, 0.000000, 0.000000; w=1.000000)
  CV(0,1) = (0.707107, 0.707107, 0.000000; w=0.707107)
  CV(0,2) = (0.000000, 1.000000, 0.000000; w=1.000000)
  CV(1,0) = (0.600000, 0.000000, 1.000000; w=1.000000)
  CV(1,1) = (0.424264, 0.424264, 1.000000; w=0.707107)
  CV(1,2) = (0.000000, 0.600000, 1.000000; w=1.000000)
  CV(2,0) = (0.800000, 0.000000, 2.000000; w=1.000000)
  CV(2,1) = (0.565685, 0.565685, 2.000000; w=0.707107)
  CV(2,2) = (0.000000, 0.800000, 2.000000; w=1.000000)
```

---

## 🔧 Build

- **Prerequisite**: OpenNURBS headers/libs.
- **C++17** (or later) recommended.

### MSVC
```
cl /std:c++17 /O2 demo.cpp opennurbs_publiclib.lib
```

### g++/clang++
```
g++ -std=c++17 -O2 demo.cpp -lopennurbs -o swung_demo
```

> 실제 링크 옵션/라이브러리 이름은 OpenNURBS 빌드 환경에 따라 다릅니다.

---

## 📝 Notes & Tips

- 입력 곡선이 **2개 모두 유리**여도 정상 동작합니다. 표면 weight는 \( w_Q = w_P w_T \).
- `alpha`로 XY 스윙의 **스케일**을 제어합니다.
- `out_srf.IsValid()`로 생성 결과를 검증할 수 있습니다.

---

## 📄 License

Add your project license here (e.g., MIT).

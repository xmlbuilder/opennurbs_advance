
# Ellipse‑based Arc → NURBS (OpenNURBS)

**개요.**  
타원(또는 타원호)을 **원(또는 원호) NURBS**로 먼저 구성한 뒤, **평면 로컬 좌표에서 Y성분만 선형 스케일**하여 **정확한 유리 NURBS 타원(호)**를 만드는 절차입니다.  
OpenNURBS의 `ON_Arc::GetNurbForm` 표준 루틴을 활용해 **간단·안정**하게 구현할 수 있습니다.

---

## 핵심 수식

타원 파라미터 \(a\)에서 점:  
![ellipse-point](https://latex.codecogs.com/svg.latex?P(a)=C+r_1\cos{a}\,X+r_2\sin{a}\,Y)

선 $$\(L(s)=C+sX\)$$ (X축) 직투영으로 “원각”:  
![theta-map](https://latex.codecogs.com/svg.latex?%5Ctheta(a)=%5Carccos%28%5Cmathrm%7Bclamp%7D%28%28P(a)-C%29%5Ccdot%20X%2Fr_1%2C-1%2C1%29%29)

> 구현에서는 `a>180°`일 때 분지 보정: $$\(\theta \leftarrow 360° - \theta\)$$.

---

## 알고리즘 요약

1. 평면 축 정규화 및 직교화  
2. 타원 시작/끝 각(as, ae)을 [0,360)로 정규화  
3. 위 수식으로 타원각 → **원각** 매핑 (시작·끝)  
4. 평면 (C,X,Y), 반지름 r1의 **원/원호 NURBS** 생성  
5. 모든 CV를 로컬 좌표로 변환 후 **Y성분만 r2/r1 배 스케일** → 월드 좌표 복원  
6. 유리성(가중치) 그대로 유지 → 결과는 **유리 타원(호) NURBS**

---

## API

```cpp
bool ON_MakeEllipseOrArcNurbs(
  ON_3dPoint  C,
  ON_3dVector X,
  ON_3dVector Y,
  double      r1,
  double      r2,
  double      as_deg,
  double      ae_deg,
  ON_NurbsCurve& out
);
```

---

## 단위 테스트 코드

```cpp
#include "opennurbs.h"
#include <cstdio>
#include <vector>
#include <cmath>
#include <algorithm>

// Orthonormalization helper
static void OrthonormalizeXY(ON_3dVector& X, ON_3dVector& Y, ON_3dVector& Z)
{
  X.Unitize();
  Y = Y - ON_DotProduct(X, Y) * X;
  Y.Unitize();
  Z = ON_CrossProduct(X, Y);
  Z.Unitize();
}

static ON_3dPoint EllipsePointDeg(
  const ON_3dPoint& C,
  const ON_3dVector& Xin,
  const ON_3dVector& Yin,
  double r1, double r2,
  double a_deg)
{
  ON_3dVector X = Xin, Y = Yin, Z;
  OrthonormalizeXY(X, Y, Z);
  const double a = ON_DegToRad(a_deg);
  return C + (r1 * std::cos(a)) * X + (r2 * std::sin(a)) * Y;
}

// 사용자 구현
bool ON_MakeEllipseOrArcNurbs(
  ON_3dPoint C, ON_3dVector X, ON_3dVector Y,
  double r1, double r2,
  double as_deg, double ae_deg,
  ON_NurbsCurve& out);

static bool CurveClosestDist(
  const ON_Curve& crv,
  const ON_3dPoint& Q,
  double& out_t,
  double& out_dist)
{
  double t;
  if (!crv.GetClosestPoint(Q, &t)) return false;
  ON_3dPoint P = crv.PointAt(t);
  out_t = t;
  out_dist = P.DistanceTo(Q);
  return true;
}

#define EXPECT_TRUE(cond, msg) \
  do { if (!(cond)) { std::printf("[FAIL] %s\n", msg); return false; } } while(0)
#define EXPECT_LE(x, y, msg) \
  do { if (!((x) <= (y))) { std::printf("[FAIL] %s (%.9g > %.9g)\n", msg, (double)(x), (double)(y)); return false; } } while(0)

// --- Tests ---
static bool Test_FullEllipse()
{
  ON_3dPoint C(0,0,0);
  ON_3dVector X(1,0,0), Y(0,1,0);
  ON_NurbsCurve nc;
  bool ok = ON_MakeEllipseOrArcNurbs(C,X,Y,20,10,0,0,nc);
  EXPECT_TRUE(ok,"ellipse build");
  EXPECT_TRUE(nc.IsValid(),"nurbs valid");

  const double tol = 1e-6 * 20.0;
  for(int i=0;i<90;++i){
    double a = 360.0*i/89;
    ON_3dPoint P = EllipsePointDeg(C,X,Y,20,10,a);
    double t,d; EXPECT_TRUE(CurveClosestDist(nc,P,t,d),"closest point");
    EXPECT_LE(d,tol,"point within tol");
  }
  return true;
}

int main(){
  ON::Begin();
  int pass=0, fail=0;
  if(Test_FullEllipse()){pass++;}else{fail++;}
  std::printf("Summary: pass=%d fail=%d\n",pass,fail);
  ON::End();
  return fail==0?0:1;
}
```

---
## 전체 소스

```cpp
bool ON_MakeEllipseOrArcNurbs(
  ON_3dPoint C,
  ON_3dVector X,
  ON_3dVector Y,
  double r1,
  double r2,
  double as_deg,
  double ae_deg,
  ON_NurbsCurve& out)
{
  if (r1 <= ON_ZERO_TOLERANCE || r2 <= ON_ZERO_TOLERANCE)
    return false;

  // 1) 축 정규화 + 직교 보정
  if (!X.Unitize()) return false;
  // Y를 X에 직교화 후 정규화
  Y = Y - (ON_DotProduct(X, Y)) * X;
  if (!Y.Unitize()) return false;
  const ON_3dVector Z = ON_CrossProduct(X, Y); // 평면 법선

  // 2) as/ae 정리 (0~360 범위로 접기)
  auto wrap360 = [](double a)->double {
    while (a < 0.0) a += 360.0;
    while (a >= 360.0) a -= 360.0;
    return a;
    };
  as_deg = wrap360(as_deg);
  ae_deg = wrap360(ae_deg);
  if (std::fabs(ae_deg - as_deg) > 360.0 + 1e-9)
    return false;

  // 3) 타원에서의 시작/끝 점을 실제로 만든 뒤,
  //    X-축 방향 직선(중심 C, 방향 X)에 직투영해서 "원 각도(asp,aep)"로 변환
  //    원본 코드와 동일한 매핑: 
  //    P = C + r1*cos(a)*X + r2*sin(a)*Y  (타원각 a에서의 점)
  //    t = dot(P-C, X) = r1*cos(a)  --> dd = t/r1 = cos(a)
  //    rad = acos(clamp(dd,-1,1))   --> asp = deg(rad), 단 a>180도면 360-asp
  auto ellipseAngleToCircleAngleDeg = [&](double a_deg)->double
    {
      const double a = ON_DegToRad(a_deg);
      const double alf = r1 * std::cos(a);
      const double bet = r2 * std::sin(a);
      const ON_3dPoint P = C + alf * X + bet * Y;

      // 직선 L(s) = C + s*X 에 대한 직투영 파라미터 s = dot(P-C, X) (X는 단위벡터)
      const double t = ON_DotProduct(P - C, X);
      double dd = t / r1;                // 이론상 cos(a)
      if (dd > 1.0) dd = 1.0;
      if (dd < -1.0) dd = -1.0;

      double rad = std::acos(dd);        // 0..pi
      double ang = ON_RadToDeg(rad); // 0..180

      // 원본과 동일한 보정: 원각은 [0,360), 타원각 a가 180 초과면 360-ang
      if (a_deg > 180.0) ang = 360.0 - ang;
      return ang;
    };

  const double asp_deg = ellipseAngleToCircleAngleDeg(as_deg);
  const double aep_deg = ellipseAngleToCircleAngleDeg(ae_deg);

  // 4) r1 원(또는 원호)을 만든다. (평면 = (C,X,Y))
  //    asp_deg -> aep_deg 사이의 원호를 생성
  ON_Plane pl(C, X, Y);
  ON_Circle circle(pl, r1);

  // full/partial 판단
  const double diff = std::fabs(aep_deg - asp_deg);
  const bool full_circle = (diff < 1e-9) || (std::fabs(diff - 360.0) < 1e-9);

  ON_NurbsCurve circle_nc;
  if (full_circle)
  {
    // 전체 원
    ON_Arc arc_full(circle, ON_2PI); // 전체 원으로부터 arc
    if (!arc_full.GetNurbForm(circle_nc))
      return false;
  }
  else
  {
    // 부분 원호: 시작/끝 각을 기준으로 점 2개와 부호로 생성
    const double s = ON_DegToRad(asp_deg);
    const double e = ON_DegToRad(aep_deg);

    // 원호는 시작/끝점과 평면을 이용해 구성하거나,
    // ON_Arc( circle, t0, t1 ) 형태를 사용
    ON_Arc arc(circle, ON_Interval(s, e));
    if (!arc.GetNurbForm(circle_nc))
      return false;
  }

  // 5) 원 NURBS의 모든 CV를 "타원 스케일"로 변환
  //    fac = r2/r1, Y성분만 fac배 스케일 (X는 그대로)
  const double fac = r2 / r1;
  if (fac <= 0.0)
    return false;

  out = circle_nc; // 결과 커브 시작은 원 NURBS
  const bool rat = out.IsRational();

  const int cv_count = out.CVCount();
  for (int i = 0; i < cv_count; ++i)
  {
    ON_4dPoint Pw;
    out.GetCV(i, Pw); // 4D (x*w, y*w, z*w, w)

    const double wcv = rat ? Pw.w : 1.0;
    ON_3dPoint P(Pw.x / wcv, Pw.y / wcv, Pw.z / wcv);

    // 월드 → 로컬(평면) 좌표 (u,v,w): P = C + u*X + v*Y + w*Z
    const ON_3dVector d = P - C;
    double u = ON_DotProduct(d, X);
    double v = ON_DotProduct(d, Y);
    double w = ON_DotProduct(d, Z); // 이론상 0 (원은 평면상), 혹시 값이 있으면 보존

    // 타원 스케일: Y성분만 fac배
    v *= fac;

    // 로컬 → 월드 복원
    ON_3dPoint Pe = C + u * X + v * Y + w * Z;

    // 동일 가중치로 4D 회귀
    if (rat) out.SetCV(i, ON_4dPoint(Pe.x * wcv, Pe.y * wcv, Pe.z * wcv, wcv));
    else     out.SetCV(i, Pe);
  }

  return out.IsValid();
}

static ON_NurbsCurve* MakeCircle(double radius, const ON_3dPoint& center, const ON_3dVector& normal)
{
  ON_Plane pln(center, normal);
  ON_Circle C(pln, radius);
  auto* c = new ON_NurbsCurve();
  if (!C.GetNurbForm(*c)) { delete c; return nullptr; }
  return c;
}

int main(int argc, const char* argv[])
{
  ON::Begin();
  ON_TextLog log;

  ON_NurbsCurve curve;
  ON_MakeEllipseOrArcNurbs(
    ON_3dPoint(0.0, 0.0, 0.0),
    ON_3dVector::XAxis,
    ON_3dVector::YAxis,
    20,
    20,
    0,
    180,
    curve
  );

  ON_Mesh mesh;
  ON_MeshParameters mp;
  mp.SetGridMaxCount(20);
  curve.CreateMesh(mp, &mesh);
  ON_ExportBDF bdf;
  bdf.Run(L"D:\\Temp\\Test1.bdf", &mesh);
 
  ON::End();
  return 0;
}
```



## 검증 체크리스트

- `nc.IsValid()==true`  
- 100~200 샘플 각도에서 최근접 오차 ≤ `1e-6 * max(r1,r2)`  
- 비직교 입력 축, 임의 평면에서도 통과  
- 부분호도 통과  
- 잘못된 입력(r≤0)에서 실패 반환


## 검증 이미지




---

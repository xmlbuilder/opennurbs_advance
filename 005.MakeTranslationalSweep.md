# 🌀 ON_MakeTranslationalSweep Example

이 문서는 OpenNURBS를 이용해 **Translational Sweep NURBS Surface**를
생성하는 방법을 설명합니다.

## 📐 Translational Sweep 생성 함수

``` cpp
bool ON_MakeTranslationalSweep(
  const ON_Curve& section_u,   // u-curve (단면 곡선)
  const ON_Curve& traj_v,      // v-curve (이동 곡선)
  ON_NurbsSurface& srf)
{
  ON_NurbsCurve su, tv;
  section_u.GetNurbForm(su);
  traj_v.GetNurbForm(tv);

  if (!su.IsValid() || !tv.IsValid()) return false;

  const int dim = su.Dimension();
  if (tv.Dimension() != dim) return false;

  const int p = su.Degree();
  const int q = tv.Degree();
  const int nu = su.CVCount();
  const int nv = tv.CVCount();

  const bool rat = su.IsRational() || tv.IsRational();

  // 표면 생성
  if (!srf.Create(dim, rat, p+1, q+1, nu, nv))
    return false;

  // knots 복사
  for (int i = 0; i < su.KnotCount(); ++i) srf.SetKnot(0, i, su.Knot(i));
  for (int j = 0; j < tv.KnotCount(); ++j) srf.SetKnot(1, j, tv.Knot(j));

  // CV 계산: P_ij = Euclid(S_i) + Euclid(T_j)
  for (int i = 0; i < nu; ++i)
  {
    ON_4dPoint Si; su.GetCV(i, Si);
    const double wu = su.IsRational() ? Si.w : 1.0;
    ON_3dPoint Eu(Si.x / wu, Si.y / wu, Si.z / wu);

    for (int j = 0; j < nv; ++j)
    {
      ON_4dPoint Tj; tv.GetCV(j, Tj);
      const double wv = tv.IsRational() ? Tj.w : 1.0;
      ON_3dPoint Ev(Tj.x / wv, Tj.y / wv, Tj.z / wv);

      const ON_3dPoint P = Eu + Ev;
      const double w = wu * wv;

      if (rat) srf.SetCV(i, j, ON_4dPoint(P.x * w, P.y * w, P.z * w, w));
      else     srf.SetCV(i, j, P);
    }
  }
  return srf.IsValid();
}
```

------------------------------------------------------------------------

## 🚀 실행 예제

``` cpp
int main(int argc, const char* argv[])
{
  ON::Begin();
  ON_TextLog log;

  ON_NurbsCurve sec;  
  ON_Circle(ON_Plane::World_xy, 1.0).GetNurbForm(sec);
  ON_NurbsCurve traj; 
  ON_LineCurve(ON_3dPoint(0, 0, 0), ON_3dPoint(0, 0, 10)).GetNurbForm(traj);

  ON_NurbsSurface srf;
  bool ok = ON_MakeTranslationalSweep(sec, traj, srf);

  srf.Dump(log);

  ON_Mesh mesh;
  ON_MeshParameters mp;
  mp.SetGridMaxCount(20);
  srf.CreateMesh(mp, &mesh);
  ON_ExportBDF bdf;
  bdf.Run(L"D:\\Temp\\Test1.bdf", &mesh);
 
  ON::End();
  return 0;
}
```

------------------------------------------------------------------------

## ✅ 실행 결과

    Knot Vector 0 ( 10 knots )
    index                     value  mult       delta
        0                        0     2
        2       1.5707963267948966     2       1.571
        4       3.1415926535897931     2       1.571
        6       4.7123889803846897     2       1.571
        8       6.2831853071795862     2       1.571

    Knot Vector 1 ( 2 knots )
    index                     value  mult       delta
        0                        0     1
        1                       10     1          10

    Control Points  18 rational points
      CV[ 0][ 0] [1, 0, 0, 1] = (1, 0, 0)
      CV[ 0][ 1] [1, 0, 10, 1] = (1, 0, 10)

      CV[ 1][ 0] [0.7071, 0.7071, 0, 0.7071] = (1, 1, 0)
      CV[ 1][ 1] [0.7071, 0.7071, 7.0711, 0.7071] = (1, 1, 10)

      CV[ 2][ 0] [0, 1, 0, 1] = (0, 1, 0)
      CV[ 2][ 1] [0, 1, 10, 1] = (0, 1, 10)

      CV[ 3][ 0] [-0.7071, 0.7071, 0, 0.7071] = (-1, 1, 0)
      CV[ 3][ 1] [-0.7071, 0.7071, 7.0711, 0.7071] = (-1, 1, 10)

      CV[ 4][ 0] [-1, 0, 0, 1] = (-1, 0, 0)
      CV[ 4][ 1] [-1, 0, 10, 1] = (-1, 0, 10)

      CV[ 5][ 0] [-0.7071, -0.7071, 0, 0.7071] = (-1, -1, 0)
      CV[ 5][ 1] [-0.7071, -0.7071, 7.0711, 0.7071] = (-1, -1, 10)

      CV[ 6][ 0] [0, -1, 0, 1] = (0, -1, 0)
      CV[ 6][ 1] [0, -1, 10, 1] = (0, -1, 10)

      CV[ 7][ 0] [0.7071, -0.7071, 0, 0.7071] = (1, -1, 0)
      CV[ 7][ 1] [0.7071, -0.7071, 7.0711, 0.7071] = (1, -1, 10)

      CV[ 8][ 0] [1, 0, 0, 1] = (1, 0, 0)
      CV[ 8][ 1] [1, 0, 10, 1] = (1, 0, 10)

------------------------------------------------------------------------

## 화면 예시
![translationsweep](/image/translate_surface.jpg)


## 📂 요약

-   `ON_MakeTranslationalSweep()` : 단면 곡선과 이동 곡선을 이용하여
    Translational Sweep Surface 생성
-   곡선 Knot 구조와 Rational 속성을 그대로 보존
-   Control Point = 단면 좌표 + 이동 좌표 (Rational일 경우 가중치 곱 적용)
-   결과: 원형 단면을 직선 방향으로 이동시킨 원통형 곡면

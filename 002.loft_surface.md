# ğŸª¡ Loft NURBS Surface from Multiple Curves (OpenNURBS)

ì—¬ëŸ¬ **ë‹¨ë©´ ê³¡ì„ (ON_Curve)** ì„ ìƒ˜í”Œë§í•´ **ë‹¨ìˆœ ë¡œí”„íŠ¸ NURBS í‘œë©´**ì„ ë§Œë“œëŠ” ì˜ˆì œì…ë‹ˆë‹¤.  
`u`/`v` ë°©í–¥ì„ ë°”ê¿” ì“¸ ìˆ˜ ìˆê³ , `u` ë°©í–¥ ì°¨ìˆ˜ë„ ì§€ì •í•  ìˆ˜ ìˆì–´ìš”.

> ì—”ì§„: **OpenNURBS**  
> ì…ë ¥: ë‹¨ë©´ ê³¡ì„ ë“¤(ë™ì¼ ë„ë©”ì¸)  
> ì¶œë ¥: `ON_NurbsSurface`

---



## âœ… í•µì‹¬ ì•„ì´ë””ì–´

- ëª¨ë“  ë‹¨ë©´ ê³¡ì„ ì˜ **ê³µí†µ íŒŒë¼ë¯¸í„° ë„ë©”ì¸** `[u0, u1]`ì„ ì‚¬ìš©í•´ `samples_u` ê°œì˜ `t`ë¥¼ ê· ì¼ ìƒ˜í”Œë§ í•©ë‹ˆë‹¤.
- ê° `t`ì—ì„œ **ëª¨ë“  ê³¡ì„ ì˜ 3D ì **ì„ ê³„ì‚°í•˜ì—¬ `W Ã— H` ê²©ì(grid)ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.  
  (`W`=ê³¡ì„  ê°œìˆ˜, `H`=ìƒ˜í”Œ ìˆ˜)
- `sweep_u=true` ì´ë©´ `u` ë°©í–¥ì„ **ê³¡ì„  ì¸ë±ìŠ¤**, `v` ë°©í–¥ì„ **ê³¡ì„  ë‚´ ìƒ˜í”Œë§**ìœ¼ë¡œ ë°°ì¹˜í•©ë‹ˆë‹¤.  
  (falseë©´ ë°˜ëŒ€ë¡œ ë°°ì¹˜)
- ì´ ê²©ìë¥¼ NURBS í‘œë©´ì˜ CVë¡œ ë³µì‚¬í•˜ê³ , ê· ì¼ í´ë¨í”„ knotë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

---

## âœ¨ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜

```cpp
bool ON_LoftCurvesSimple(
  const std::vector<const ON_Curve*>& curves, // ë‹¨ë©´ ê³¡ì„ ë“¤ (>=2)
  int   samples_u,                            // ê° ê³¡ì„ ì—ì„œ u ìƒ˜í”Œ ê°œìˆ˜ (>=2 ê¶Œì¥)
  bool  sweep_u,                              // true: u=ê³¡ì„  ì¸ë±ìŠ¤, v=ìƒ˜í”Œ
  int   deg_sweep,                            // uë°©í–¥ ì°¨ìˆ˜
  ON_NurbsSurface& srf                        // ê²°ê³¼ í‘œë©´
);
```

---

## ğŸ”§ êµ¬í˜„ (ê·¸ëŒ€ë¡œ ë¶™ì—¬ ë„£ì–´ ì‚¬ìš©)

```cpp
#include <vector>
#include <algorithm> // std::min, std::max, std::clamp
// OpenNURBS í—¤ë”ëŠ” í™˜ê²½ì— ë§ê²Œ í¬í•¨
// #include "opennurbs.h"

bool ON_LoftCurvesSimple(
  const std::vector<const ON_Curve*>& curves,
  int samples_u, 
  bool sweep_u,
  int deg_sweep, 
  ON_NurbsSurface& srf)
{
  if (curves.size() < 2) return false;

  // ê³µí†µ ë„ë©”ì¸ (ëª¨ë“  ê³¡ì„ ì´ ë™ì¼ ë„ë©”ì¸ì´ë¼ ê°€ì •)
  double cu0, cu1;
  curves[0]->GetDomain(&cu0, &cu1);

  const int W = static_cast<int>(curves.size());
  const int H = std::max(4, samples_u);

  // W x H í¬ì¸íŠ¸ ê·¸ë¦¬ë“œ
  std::vector<ON_3dPoint> grid(W * H);
  for (int j = 0; j < H; ++j)
  {
    const double t = cu0 + (cu1 - cu0) * (double)j / (H - 1);
    for (int i = 0; i < W; ++i)
      grid[j * W + i] = curves[i]->PointAt(t);
  }

  // u,v ë°°ì¹˜: sweep_u=true â†’ u=W, v=H
  int nu = sweep_u ? W : H;
  int nv = sweep_u ? H : W;

  auto at = [&](int iu, int iv) -> const ON_3dPoint&
  {
    return sweep_u ? grid[iv * W + iu] : grid[iu * W + iv];
  };

  // ì°¨ìˆ˜ ê²°ì •
  const int du = std::clamp(deg_sweep, 1, nu - 1);
  const int dv = std::min(3, nv - 1); // vëŠ” ì ë‹¹íˆ 3ì°¨ ì´í•˜

  // í‘œë©´ ìƒì„± (dim=3, non-rational)
  srf = ON_NurbsSurface(3, false, du + 1, dv + 1, nu, nv);

  // CV ë³µì‚¬
  for (int iv = 0; iv < nv; ++iv)
    for (int iu = 0; iu < nu; ++iu)
      srf.SetCV(iu, iv, at(iu, iv));

  // ê· ì¼ í´ë¨í”„ knot
  srf.MakeClampedUniformKnotVector(0, 1.0);
  srf.MakeClampedUniformKnotVector(1, 1.0);

  ON_TextLog log;
  return srf.IsValid(&log);
}
```

---

## â• í…ŒìŠ¤íŠ¸ìš© í—¬í¼ & ì˜ˆì œ `main()`

```cpp
// íƒ€ì› ê³¡ì„  ìƒì„± (ìœ ë¦¬ NURBS)
static ON_NurbsCurve* MakeEllipse(
  double rx, double ry,
  const ON_3dPoint& center,
  const ON_3dVector& normal)
{
  ON_Plane pln(center, normal);
  ON_Ellipse E(pln, rx, ry);
  auto* c = new ON_NurbsCurve();
  if (!E.GetNurbForm(*c)) { delete c; return nullptr; }
  return c;
}

int main()
{
  ON::Begin();
  ON_TextLog log;

  ON_SimpleArray<ON_NurbsCurve*> owned;
  std::vector<const ON_Curve*> sections;

  // ë‹¨ë©´ ê³¡ì„  3~4ê°œ
  auto* c0 = MakeEllipse(5.0, 2.0, ON_3dPoint(0,0,0), ON_3dVector::ZAxis);
  auto* c1 = MakeEllipse(9.0, 4.5, ON_3dPoint(0,0,2), ON_3dVector::ZAxis);
  auto* c2 = MakeEllipse(2.5, 1.0, ON_3dPoint(0,0,4), ON_3dVector::ZAxis);
  auto* c3 = MakeEllipse(2.5, 2.0, ON_3dPoint(0,0,6), ON_3dVector::ZAxis);

  if (!c0 || !c1 || !c2 || !c3) {
    log.Print("Ellipse creation failed.\n");
    if (c0) delete c0; if (c1) delete c1; if (c2) delete c2; if (c3) delete c3;
    ON::End(); return 1;
  }
  owned.Append(c0); owned.Append(c1); owned.Append(c2); owned.Append(c3);

  // ì´ë²ˆ ë°ëª¨ëŠ” 3ê°œë§Œ ì‚¬ìš©
  sections = { c0, c1, c2 };

  ON_NurbsSurface srf;
  const int  samples_u = 9;    // ê³¡ì„  ë‚´ ìƒ˜í”Œ ìˆ˜
  const bool sweep_u   = true; // u=ê³¡ì„  ì¸ë±ìŠ¤
  const int  deg_u     = 3;    // u ì°¨ìˆ˜

  const bool ok = ON_LoftCurvesSimple(sections, samples_u, sweep_u, deg_u, srf);
  if (!ok) {
    log.Print("Loft failed.\n");
    for (int i = 0; i < owned.Count(); ++i) delete owned[i];
    ON::End(); return 1;
  }

  // ê°„ë‹¨ ë©”ì‹œ ìƒì„± (ì‹œê°í™”/ë‚´ë³´ë‚´ê¸°ìš©)
  //ON_Mesh mesh;
  //ON_MeshParameters mp; mp.SetGridMaxCount(20);
  //srf.CreateMesh(mp, &mesh);

  // í•„ìš” ì‹œ ë‚´ë³´ë‚´ê¸° (ì‚¬ìš© í™˜ê²½ì— ë§ê²Œ êµ¬í˜„/êµì²´)
  // ON_ExportBDF bdf;
  // bdf.Run(L"D:\\Temp\\Test1.bdf", &mesh);

  for (int i = 0; i < owned.Count(); ++i) delete owned[i];
  ON::End();
  return 0;
}
```

---

## ğŸ“¸ ê²°ê³¼ ì´ë¯¸ì§€ (ì—¬ê¸°ì— ìŠ¤í¬ë¦°ìƒ· ë„£ì–´ì£¼ì„¸ìš”)

> ì•„ë˜ ê²½ë¡œ/íŒŒì¼ëª…ì„ í”„ë¡œì íŠ¸ì— ë§ê²Œ ë°”ê¿” ì‚¬ìš©í•˜ì„¸ìš”.


![Loft demo](/image/loft.jpg)


---


## ğŸ§­ íŒŒë¼ë¯¸í„° ê°€ì´ë“œ

- `samples_u`  
  ê° ë‹¨ë©´ ê³¡ì„ ì—ì„œ ìƒ˜í”Œë§í•  `u` ê°œìˆ˜. í´ìˆ˜ë¡ vë°©í–¥ í•´ìƒë„ ì¦ê°€.
- `sweep_u`  
  `true`ë©´ `u=ê³¡ì„  ì¸ë±ìŠ¤`, `v=ìƒ˜í”Œ`. (ì—¬ëŸ¬ ì„¹ì…˜ì„ uë¡œ â€œíœ©ì“´ë‹¤â€ëŠ” ëŠë‚Œ)  
  `false`ë©´ ë°˜ëŒ€ ë°°ì¹˜.
- `deg_sweep`  
  `u` ë°©í–¥ ì°¨ìˆ˜. `1..(nu-1)` ë²”ìœ„ ë‚´ì—ì„œ `std::clamp`.

---

## ğŸ—ï¸ ë¹Œë“œ

- **ì „ì œ**: OpenNURBS í—¤ë”/ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¤€ë¹„
- **ê¶Œì¥**: C++17 ì´ìƒ

### MSVC
```bat
cl /std:c++17 /O2 demo.cpp opennurbs_publiclib.lib
```

### g++ / clang++
```bash
g++ -std=c++17 -O2 demo.cpp -lopennurbs -o loft_demo
```

> ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ë¦„/ê²½ë¡œëŠ” OpenNURBS ë¹Œë“œ ë°©ì‹ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤.

---

## ğŸ“ ë©”ëª¨ & íŒ

- ëª¨ë“  ê³¡ì„ ì´ **ë™ì¼ ë„ë©”ì¸**ì„ ê°–ëŠ”ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤. ë‹¤ë¥´ë©´ `Reparameterize()` ë“±ìœ¼ë¡œ ë§ì¶”ì„¸ìš”.
- í˜„ì¬ êµ¬í˜„ì€ **ë¹„ìœ ë¦¬ í‘œë©´**(rational=false)ì„ ìƒì„±í•©ë‹ˆë‹¤. í•„ìš”í•˜ë©´ ê°€ì¤‘ì¹˜ ì²˜ë¦¬ ë¡œì§ì„ ì¶”ê°€í•  ìˆ˜ ìˆì–´ìš”.
- ë©”ì‹œ í•´ìƒë„ëŠ” `ON_MeshParameters` ë¡œ ì¡°ì •í•˜ì„¸ìš”.

---

## ğŸ“„ ë¼ì´ì„ ìŠ¤

ì›í•˜ëŠ” ë¼ì´ì„ ìŠ¤ë¥¼ í”„ë¡œì íŠ¸ ë£¨íŠ¸ `LICENSE` íŒŒì¼ë¡œ ì¶”ê°€í•˜ì„¸ìš”. (ì˜ˆ: MIT)

ì¦ê±°ìš´ ì„œí”¼ì‹±! ğŸ„â€â™‚ï¸

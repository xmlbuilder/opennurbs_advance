# ðŸ“˜ ON_LM_NewtonClosestUV: Surface Point Inversion

## ë¬¸ì œ ì •ì˜
ì£¼ì–´ì§„ 3D ì  **Q** ì™€ ë§¤ê°œë³€ìˆ˜í™”ëœ ê³¡ë©´

$$
S(u,v): \mathbb{R}^2 \to \mathbb{R}^3
$$

ê°€ ìžˆì„ ë•Œ, ëª©í‘œëŠ” **ê³¡ë©´ ìœ„ì˜ ìµœê·¼ì ‘ì **ì„ ì°¾ëŠ” ê²ƒì´ë‹¤:

![equation](https://latex.codecogs.com/svg.latex?(u^*,v^*)=\arg\min_{(u,v)}f(u,v))

$$
f(u,v) = \tfrac{1}{2}\| S(u,v) - Q \|^2
$$



---

## ê·¸ëž˜ë””ì–¸íŠ¸ì™€ í—¤ì„¸ í–‰ë ¬

### ìž”ì°¨ ë²¡í„°
$$
r(u,v) = S(u,v) - Q
$$

### 1ê³„ ë¯¸ë¶„ (Gradient)
$$
\frac{\partial f}{\partial u} = \langle r, S_u \rangle, \quad 
\frac{\partial f}{\partial v} = \langle r, S_v \rangle
$$

ë”°ë¼ì„œ

$$
\nabla f(u,v) =
\begin{bmatrix}
\langle r, S_u \rangle \\
\langle r, S_v \rangle
\end{bmatrix}
$$

### 2ê³„ ë¯¸ë¶„ (Hessian)
$$
\frac{\partial^2 f}{\partial u^2} = \langle S_u, S_u \rangle + \langle r, S_{uu} \rangle
$$
$$
\frac{\partial^2 f}{\partial u \partial v} = \langle S_u, S_v \rangle + \langle r, S_{uv} \rangle
$$
$$
\frac{\partial^2 f}{\partial v^2} = \langle S_v, S_v \rangle + \langle r, S_{vv} \rangle
$$

í—¤ì„¸ í–‰ë ¬:

$$
H =
\begin{bmatrix}
\langle S_u, S_u \rangle + \langle r, S_{uu} \rangle & \langle S_u, S_v \rangle + \langle r, S_{uv} \rangle \\
\langle S_u, S_v \rangle + \langle r, S_{uv} \rangle & \langle S_v, S_v \rangle + \langle r, S_{vv} \rangle
\end{bmatrix}
$$

---

## ë‰´í„´ ì—…ë°ì´íŠ¸

ë‰´í„´ë²•ì€

$$
\Delta =
\begin{bmatrix}
\Delta u \\ \Delta v
\end{bmatrix}
= - H^{-1} \nabla f
$$

ì—…ë°ì´íŠ¸:

$$
u \leftarrow u + \Delta u, \quad v \leftarrow v + \Delta v
$$

---

## Levenbergâ€“Marquardt ê°ì‡ 

í—¤ì„¸ê°€ íŠ¹ì´í•˜ê±°ë‚˜ ìˆ˜ì¹˜ì ìœ¼ë¡œ ë¶ˆì•ˆì •í•˜ë©´ ë°œì‚°í•  ìˆ˜ ìžˆë‹¤.  
ë”°ë¼ì„œ LM ê°ì‡  í•­ì„ ì¶”ê°€:

$$
H' = H + \lambda I
$$

ì—¬ê¸°ì„œ $$\(\lambda > 0\)$$ ëŠ” ìž‘ì€ ê°’ìœ¼ë¡œ, ìž‘ì€ ê³ ìœ ê°’ì„ ë°€ì–´ì˜¬ë ¤ ì•ˆì •ì„±ì„ ë†’ì¸ë‹¤.

---

## ë¼ì¸ì„œì¹˜ (Backtracking)

ìŠ¤í… í¬ê¸°ë¥¼ ì§ì ‘ ì ìš©í•˜ë©´ overshoot ê°€ëŠ¥ì„±ì´ ìžˆë‹¤.  
ë”°ë¼ì„œ backtracking ìœ¼ë¡œ $$\(\alpha \in (0,1]\)$$ ë¥¼ ì¤„ì—¬ê°€ë©° ë‹¤ìŒ ì¡°ê±´ ë§Œì¡± ì‹œ ì±„íƒí•œë‹¤:

$$
f(u - \alpha \Delta u, v - \alpha \Delta v) \le f(u,v) - c \alpha \| \nabla f \|^2
$$

ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë‹¨ìˆœížˆ stepì„ Â½ì”© ì¤„ì´ë©° ìž”ì°¨ ê°ì†Œ ì—¬ë¶€ë¥¼ í™•ì¸í•œë‹¤.

---

## ì•Œê³ ë¦¬ì¦˜ ìš”ì•½ (ì˜ì‚¬ì½”ë“œ)

```cpp
(u,v) = ì´ˆê¸° ì‹œë“œ (coarse sampling or analytic)
for iter in 0..max_iter:
    S, Su, Sv, Suu, Suv, Svv = Evaluate(surface, u, v)
    r = S - Q

    // gradient
    g = [ dot(r, Su), dot(r, Sv) ]

    // Hessian with LM damping
    H = [[ dot(Su,Su)+dot(r,Suu), dot(Su,Sv)+dot(r,Suv) ],
         [ dot(Su,Sv)+dot(r,Suv), dot(Sv,Sv)+dot(r,Svv) ]]
    H += Î» * I

    Î” = - H^{-1} g

    // line-search
    step = 1.0
    while step > min_step:
        u_new = normalize(u + step*Î”u)
        v_new = normalize(v + step*Î”v)
        if f(u_new,v_new) < f(u,v):
            accept; break
        step *= 0.5

    if |Î”|^2 < tol^2 or ||r||^2 < tol3d^2:
        return (u,v) ì„±ê³µ
```
---

## ì‹¤ì œ ì½”ë“œ
```cpp
// --- LM(ê°ì‡ ) + ë¼ì¸ì„œì¹˜ ë‰´í„´ ---
bool ON_LM_NewtonClosestUV(
  const ON_Surface& srf,
  const ON_3dPoint& Q,
  const ON_Interval& du,
  const ON_Interval& dv,
  bool up, bool vp,
  double tol3d,
  int max_iter,
  double& u,
  double& v)
{
  auto normU = [&](double x){ return up?WrapTo(du,x):Clamp(x,du.Min(),du.Max()); };
  auto normV = [&](double y){ return vp?WrapTo(dv,y):Clamp(y,dv.Min(),dv.Max()); };

  u = normU(u); v = normV(v);

  const double lam = 1e-12;      // LM ê°ì‡ 
  const double tolParam2 = 1e-24;

  ON_3dPoint S; ON_3dVector Su,Sv;
  if(!srf.Ev1Der(u,v,S,Su,Sv)) return false;

  for (int it=0; it<max_iter; ++it){
    ON_3dVector r = S - Q;
    double r2 = r.LengthSquared();
    if (r2 <= tol3d*tol3d) return true;

    double a = ON_DotProduct(Su,Su) + lam;
    double b = ON_DotProduct(Su,Sv);
    double c = ON_DotProduct(Sv,Sv) + lam;
    double g0= ON_DotProduct(r,Su);
    double g1= ON_DotProduct(r,Sv);
    double det = a*c - b*b;
    if (fabs(det) < 1e-20) return false;

    double du_step = (-c*g0 + b*g1)/det;
    double dv_step = ( b*g0 - a*g1)/det;

    double step=1.0; bool ok=false;
    for (int ls=0; ls<8; ++ls){
      double uu = normU(u - step*du_step); // steepest descent of 1/2||r||^2
      double vv = normV(v - step*dv_step);
      ON_3dPoint Stry; if(!srf.EvPoint(uu,vv,Stry)) break;
      double r2try = Stry.DistanceTo(Q); r2try*=r2try;
      if (r2try < r2*(1.0 - 0.25*step)) { u=uu; v=vv; ok=true; break; }
      step *= 0.5;
    }
    if(!ok) return false;

    if(!srf.Ev1Der(u,v,S,Su,Sv)) return false;

    if (du_step*du_step + dv_step*dv_step <= tolParam2) return true;

    // pole guard
    ON_3dVector N = ON_CrossProduct(Su,Sv);
    if (N.LengthSquared() < 1e-20){
      v = normV(v + 1e-6*dv.Length());
      if (!srf.Ev1Der(u,v,S,Su,Sv)) return false;
    }
  }
  return (srf.PointAt(u,v).DistanceTo(Q) <= tol3d);
}

```
---
# ðŸ”§ LM_NewtonClosestUV ë³´ê°• ë²„ì „ (Trust-Region + LM)

ì´ ë¬¸ì„œëŠ” `ON_LM_NewtonClosestUV` ë£¨í‹´ì„ **ì‹ ë¢°ì˜ì—­(Trust-Region) ê¸°ë°˜ Levenbergâ€“Marquardt (LM)** ë°©ì‹ìœ¼ë¡œ ë³´ê°•í•œ ë‚´ìš©ìž…ë‹ˆë‹¤.  

---

## ðŸ“Œ í•µì‹¬ ì•„ì´ë””ì–´

1. **Marquardt ìŠ¤ì¼€ì¼**  
   - `(Jáµ€J + Î»Â·diag(Jáµ€J)) Î” = âˆ’Jáµ€r`  
   - ë³€ìˆ˜ ìŠ¤ì¼€ì¼ ë¶ˆê· í˜•ì— ì•ˆì •ì 

2. **ì‹ ë¢°ì˜ì—­ / ê°ì†Œìœ¨ í‰ê°€**  
   - ì˜ˆì¸¡ ê°ì†ŒëŸ‰ `pred`, ì‹¤ì œ ê°ì†ŒëŸ‰ `ared`  
   - ë¹„ìœ¨ `Ï = ared/pred`ë¡œ ìŠ¤í… í’ˆì§ˆ í‰ê°€  
   - `Ï` ë†’ìœ¼ë©´ Î»â†“, ë‚®ìœ¼ë©´ Î»â†‘ (ëŒí•‘ ìžë™í™”)

3. **ì•ˆì „ ìž¥ì¹˜**  
   - detâ‰ˆ0 â†’ Î» í™•ìž¥, ë¯¸ì„¸ ì§„ë™ìœ¼ë¡œ íƒˆì¶œ  
   - ë„ë©”ì¸ ê¸¸ì´ ê¸°ë°˜ ì‹ ë¢°ì˜ì—­ ë°˜ê²½ìœ¼ë¡œ í­ì£¼ ë°©ì§€

4. **ì •ì§€ ì¡°ê±´ ê°œì„ **  
   - ê±°ë¦¬ë¿ ì•„ë‹ˆë¼ **ê·¸ëž˜ë””ì–¸íŠ¸ í¬ê¸°**ì™€ **ì‹¤ì œ ê°ì†ŒëŸ‰ ì •ì²´**ë„ í•¨ê»˜ ê³ ë ¤

5. **ìµœì„  í›„ë³´ ë³´ì¡´**  
   - ë°˜ë³µ ì¤‘ í•­ìƒ ìµœì†Œ fë¥¼ ë³´ì¡´í•˜ì—¬ ì‹¤íŒ¨ ì‹œì—ë„ ë§ˆì§€ë§‰ best (u,v) ë°˜í™˜

---

## ðŸ“ ì˜ì‚¬ ì½”ë“œ (ë£¨í”„ ë‚´ë¶€ êµì²´)

```cpp
// LM ì‹œìŠ¤í…œ (Marquardt)
double j11 = suu, j22 = svv, j12 = suv;
double d11 = j11, d22 = j22;
double A11 = j11 + lambda*d11;
double A22 = j22 + lambda*d22;
double A12 = j12;

double det = A11*A22 - A12*A12;
double du=0.0, dv=0.0;
if (fabs(det) < 1e-20) {
  lambda *= 10.0;
  u = clamp_wrap(u + 1e-6*U.Length(), U, srf.IsPeriodic(0));
  v = clamp_wrap(v + 1e-6*V.Length(), V, srf.IsPeriodic(1));
  continue;
}
double inv = 1.0/det;
du = inv * (-A22 * (Su*r) + A12 * (Sv*r));
dv = inv * ( A12 * (Su*r) - A11 * (Sv*r));

// ì‹ ë¢°ì˜ì—­ ë°˜ê²½ ì œí•œ
double rad_u = 0.35*U.Length();
double rad_v = 0.35*V.Length();
du = std::clamp(du, -rad_u, rad_u);
dv = std::clamp(dv, -rad_v, rad_v);

// í›„ë³´ í‰ê°€
double f2_try; ON_3dPoint S_try;
auto [u_try, v_try] = eval_at(u+du, v+dv, f2_try, &S_try);

// ì˜ˆì¸¡/ì‹¤ì œ ê°ì†ŒëŸ‰
double gu = Su*r, gv = Sv*r;
double quad = j11*du*du + 2.0*j12*du*dv + j22*dv*dv;
double lin  = gu*du + gv*dv;
double pred = -(lin) - 0.5*quad;
if (pred <= 0.0) pred = 1e-20;

double ared = f2 - f2_try;
double rho  = ared / pred;

// ìŠ¤í… ì±„íƒ/ê±°ë¶€
bool accepted = (f2_try < f2) && (rho > 1e-4);
if (accepted) {
  u = u_try; v = v_try;
  if (f2_try < f2_best) { f2_best=f2_try; best_u=u; best_v=v; }
  if (rho > 0.75)      lambda = max(1e-12, lambda*0.33);
  else if (rho < 0.25) lambda = min(1e+12, lambda*2.5);
} else {
  lambda = min(1e+12, lambda*4.0);
  double alpha=0.5; bool ok=false;
  for (int ls=0; ls<10; ++ls) {
    double f2_bt; ON_3dPoint S_bt;
    auto [uu,vv] = eval_at(u+alpha*du, v+alpha*dv, f2_bt, &S_bt);
    if (f2_bt < f2) { u=uu; v=vv; f2_try=f2_bt; ok=true; break; }
    alpha *= 0.5;
  }
  if (!ok) {
    u = clamp_wrap(u + 1e-6*U.Length(), U, srf.IsPeriodic(0));
    v = clamp_wrap(v + 1e-6*V.Length(), V, srf.IsPeriodic(1));
    continue;
  }
}

// ì¢…ë£Œ ì¡°ê±´
double grad_inf = max(fabs(gu), fabs(gv));
if (sqrt(f2_try) <= tol) break;
if (grad_inf <= 1e-10*(1.0 + sqrt(f2_try))) break;
if (fabs(ared) <= 1e-16*(1.0 + f2)) break;
```

## âœ… ì ìš© ì§€ì¹¨

Î» ì´ˆê¸°ê°’: 1e-3 ~ 1e+0 ì ë‹¹

ì‹ ë¢°ì˜ì—­ ë¹„ìœ¨: seam ë¯¼ê° ì‹œ 0.25

analytic(sphere/cylinder) ë£¨íŠ¸ëŠ” ê·¸ëŒ€ë¡œ ë‘ê³ , LMì€ í´ë°±/ì„¸ë°€ ì¡°ì • ë‹´ë‹¹

íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ì—ëŠ” max_snap ê²Œì´íŠ¸ ì¶”ê°€í•´ì„œ ì›ê±°ë¦¬ ë°ì´í„° ì°¨ë‹¨


## ðŸ“Š ê¸°ëŒ€ íš¨ê³¼

êµ¬/ì›í†µ/ê·¹ì ì—ì„œë„ ì•ˆì •ì  ìˆ˜ë ´

plateauÂ·seam ì¸ê·¼ì—ì„œ ì§„ë™ ë°©ì§€

ë¹ ë¥¸ ìˆ˜ë ´ êµ¬ê°„ì—ì„œëŠ” Gaussâ€“Newton ìˆ˜ì¤€ ì†ë„ë¡œ ìˆ˜ë ´

í•­ìƒ ìµœì†Œ í›„ë³´ ë³´ì¡´ â†’ ì‹¤íŒ¨ì‹œì—ë„ best í•´ ë°˜í™˜

---



# NURBS Offset Curve (OpenNURBS) — 문서 & 예제

이 문서는 **평면 NURBS 곡선의 오프셋 곡선**을 생성하는 간단한 구현과 그 **수학적 배경**을 정리합니다.  
정확한 의미의 **기하학적 오프셋**은 일반적으로 NURBS로 **닫히지 않으며**, 라인/원(호) 등 특수한 경우를 제외하면 근사/구성법이 필요합니다.  
여기서는 **컨트롤 폴리곤 오프셋 + 교점 연결** 방식의 경량 구현을 보여주고, 테스트 코드를 제공합니다.

---

## 1) 수학적 배경

### 1.1 곡선 오프셋의 정의

평면 위 매개변수 곡선 $$\(C(u) \in \mathbb{R}^2\)$$ (또는 $$\(\mathbb{R}^3\)$$ 평면 내에 놓인 경우)와 고정 거리 $$\(d\)$$에 대해, **이상적인 오프셋 곡선**은

$$
C_\text{off}(u) = C(u) + d\,\mathbf{n}(u)
$$

으로 정의합니다. 여기서 $$\(\mathbf{n}(u)\)$$는 **단위 법선**으로, (평면 곡선에서) 단위 접선 $$\(\mathbf{t}(u)\)$$와 **평면 법선** $$\(\mathbf{k}\)$$ (예: $$\((0,0,1)\))$$으로부터

$$
\mathbf{t}(u) = \frac{C'(u)}{\|C'(u)\|},\qquad
\mathbf{n}(u) = \mathbf{k} \times \mathbf{t}(u)
$$

로 얻을 수 있습니다(또는 2D 회전연산으로 $\left(\mathbf{t}^\perp\right)$.

> 3D 일반 곡선의 경우 프레네 법선(주법선)이나 선택한 기준면의 법선을 사용해야 하며, 오프셋의 정의가 애매해집니다. 본 구현은 **평면 오프셋**을 가정합니다.

### 1.2 NURBS 오프셋의 비폐쇄성

- NURBS의 정확한 오프셋은 보통 **유리 곡선의 차수 상승/가중치 변화**를 필요로 하며, 일반적인 NURBS 클래스에 그대로 **닫히지 않습니다**.  
- 따라서 CAD 실무에서는
  1) **곡선을 충분히 샘플링 후 보간/근사**하거나,
  2) **컨트롤 폴리곤을 오프셋**하여 코너에서 교점으로 재구성,
  3) 전용 오프셋 알고리즘(보간/적응 재매개화 + 스무딩)

  등의 실용적 기법을 사용합니다.

여기에서는 **(2) 컨트롤 폴리곤 오프셋 + 코너 교점 연결** 기법을 구현합니다.

---

## 2) 구현 개요 (컨트롤 폴리곤 기반)

1. 원 곡선의 각 컨트롤 포인트 \(P_i\) 에 대하여, **해당 포인트의 최근접 파라미터** \(u_i\) 를 찾습니다.  
2. 곡선의 (평면) 법선 $$\(\mathbf{n}(u_i)\)$$를 구해, 각 포인트를 **$$\(d \mathbf{n}(u_i)\)$$** 만큼 평행이동하여 임시 점 집합 $$\(\{\tilde P_j\}\)$$을 만듭니다.  
3. 연속한 **두 개의 오프셋 선분** $$\(\overline{\tilde P_{2k}\tilde P_{2k+1}}\)$$ 와 $$\(\overline{\tilde P_{2k+2}\tilde P_{2k+3}}\)$$ 의 **교점**을 계산하여 코너에서 자연스러운 만남이 되도록 합니다.  
4. 이렇게 얻은 새 꼭짓점들로 **원래와 동일한 노트/차수**를 가진 NURBS에 **CV만 갱신**하여 결과 오프셋 곡선을 만듭니다.

> 간단하고 빠른 대신, **곡률 급변/곡선의 감김/내측 오프셋 자가교차** 등 어려운 사례에서는 정교한 후처리(코너 라운딩, 자가교차 제거, 재매개화)가 필요합니다.

---

## 3) 예제: NURBS 구성 & 오프셋

### 3.1 원본 곡선 구성

```cpp
int degree = 2;
ON_SimpleArray<double> kv;
kv.Append({ 0,0,1,2,3,3 });

ON_NurbsCurve curve = ON_NurbsCurve(3, true , degree + 1, 5); // dim=3, rational, order=3, cv=5
for (int i = 0; i < kv.Count(); i++)
  curve.SetKnot(i, kv[i]);

curve.SetCV(0, ON_4dPoint(0, 0, 0, 1));
curve.SetCV(1, ON_4dPoint(4, 4, 0, 4));  // 가중치 4 → 합리적 원호 성분 예시
curve.SetCV(2, ON_4dPoint(3, 2, 0, 1));
curve.SetCV(3, ON_4dPoint(4, 1, 0, 1));
curve.SetCV(4, ON_4dPoint(5, -1, 0, 1));
curve.Dump(log);
```

### 3.2 오프셋 호출

```cpp
ON_NurbsCurve* offsetCrv = nullptr;
if (curve.Offset(0.1, offsetCrv))
{
  offsetCrv->Dump(log);
  delete offsetCrv;
}
```

---

## 4) 핵심 코드 (발췌)

### 오프셋 구현

```cpp
bool ON_NurbsCurve::Offset(double offset, ON_NurbsCurve*& result)
{
  int cntCtrlPt = CVCount();
  if (ON_AreEqual(offset, 0.0))
  {
    result = new ON_NurbsCurve(*this);
    return true;
  }

  std::vector<ON_3dPoint> tmpPoints;
  tmpPoints.reserve(2 * (size_t)(cntCtrlPt - 1));

  for (int i = 0; i < cntCtrlPt - 1; i++)
  {
    ON_3dPoint currentPoint0 = ON_3dPoint(ControlPoint(i));
    double param0 = 0.0;
    GetClosestPoint(currentPoint0, &param0);

    ON_3dPoint currentPoint1 = ON_3dPoint(ControlPoint(i+1));
    double param1 = 0.0;
    GetClosestPoint(currentPoint1, &param1);

    ON_3dPoint newPoint0 = currentPoint0 + offset * NormalAt(param0);
    ON_3dPoint newPoint1 = currentPoint1 + offset * NormalAt(param1);

    tmpPoints.emplace_back(newPoint0);
    tmpPoints.emplace_back(newPoint1);
  }

  std::vector<ON_4dPoint> newCtrlPts;
  newCtrlPts.reserve(cntCtrlPt);
  newCtrlPts.emplace_back(ON_4dPoint(tmpPoints[0]));

  int cntPoint = (int)tmpPoints.size();
  for (int i = 0; i < cntPoint - 2; i += 2)
  {
    ON_3dPoint  curP0 = tmpPoints[i];
    ON_3dPoint  curP1 = tmpPoints[i + 1];
    ON_3dPoint  nextP0 = tmpPoints[i + 2];
    ON_3dPoint  nextP1 = tmpPoints[i + 3];

    double s0, s1;
    ON_3dPoint X;
    LineLineIntersectionType type = ON_IntersectLineLineType(
      curP0,  curP1 - curP0,
      nextP1, nextP0 - nextP1,
      s0, s1, X);

    if (type != LineLineIntersectionType::Intersecting)
      return false;

    newCtrlPts.emplace_back(ON_4dPoint(X));
  }
  newCtrlPts.emplace_back(ON_4dPoint(tmpPoints[cntPoint - 1]));

  result = new ON_NurbsCurve(*this);
  for (int i = 0; i < (int)newCtrlPts.size(); i++)
    result->SetCV(i, newCtrlPts[i]);

  return true;
}
```

---

## 5) 테스트 코드

```cpp
int degree = 2;
ON_SimpleArray<double> kv;
kv.Append({ 0,0,1,2,3,3 });
ON_NurbsCurve curve(3, true , degree + 1, 5);
for (int i = 0; i < kv.Count(); i++) curve.SetKnot(i, kv[i]);

curve.SetCV(0, ON_4dPoint(0, 0, 0, 1));
curve.SetCV(1, ON_4dPoint(4, 4, 0, 4));
curve.SetCV(2, ON_4dPoint(3, 2, 0, 1));
curve.SetCV(3, ON_4dPoint(4, 1, 0, 1));
curve.SetCV(4, ON_4dPoint(5, -1, 0, 1));

ON_NurbsCurve* offsetCrv = nullptr;
if (curve.Offset(0.1, offsetCrv))
{
  offsetCrv->Dump(log);
  delete offsetCrv;
}
```

---
